# Week 9: Flask

Instructor: **[David J. Malan](https://github.com/dmalan)**

---

## Static to Dynamic

Up until this point, all HTML you saw was pre-written and `static`.

In the past, when you visited a page, the browser downloaded an **HTML** page, and you were able to view it. 
These are considered static pages, in that what programmed in the **HTML** is exactly what the user sees and 
downloads to their internet browser.

`Dynamic` pages refer to the ability of **Python** and similar languages to create **HTML** files on-the-fly. 
Accordingly, you can have _web pages that are generated by options selected by your user_.

We have used `http-server` in the past to serve our web pages on the problem set. Today, we are going to utilize
a new server that can parse out a web address and perform actions based on the URL provided.

> Last week, we focused on **websites**, this week we'll focus on **web applications**.

We are already familiar with addresses like these:

```
https://www.example.com/
https://www.example.com/file.html
https://www.example.com/folder/
https://www.example.com/folder/file.html
```

From now, we will think of everything after the domain name as a path or `route`:

```
https://www.example.com/route
```

But what makes it an application?
- With `key/value` websites can take an input.

```
https://www.example.com/route?key=value
https://www.example.com/route?key=value&key=value
https://www.example.com/route?key=value&key=value&key=value
```

## Flask

Flask - a third-party library or a microframework, makes easier to implement a web application using Python.

Previously, we use `http-server`, but to use Flask and start a web-server to run, we need to use another command:

```commandline
flask run
```

Flask has pieces of functionality, for example:
1. `Flask`
2. `render_template`
3. `request`

### -- Example `hello-1`

- `app.py` - our python program;
- `requirements.txt` - list of used third-party libraries;
- `static/` - a folder with images, .css, .js - files that ment to be static;
- `templates/` - a folder, where we'll keep .html.

At first, let's write a web application that simply greets everyone.

#### ---- `app-1.py`

```python
from flask import Flask, render_template, request

# Pass the file name to Flask, without specifying it
app = Flask(__name__)

# "/" - default folder
@app.route("/")
# route() defines the route of an application, so that when user visit "/" on this app
# it will call index() and write "hello, world"
def index():
    return "hello, world"
```

When we view the **Page Source** through browser we get just one line from .py:
```
hello, world
```

### -- Example `hello-2`

#### ---- `app-2.py`

```python
from flask import Flask, render_template, request

# Pass the file name to Flask, without specifying it
app = Flask(__name__)

# "/" - default folder
@app.route("/")
# route() defines the route of an application, so that when user visit "/" on this app
# it will call render_template()
def index():
    # render_template() gets the file, opens it and sends to user's browser
    return render_template("index.html")
```

This time our **Page Source** gets entire `index.html`:

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- No matter how wide the device is, size the viewport to that device -->
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>hello</title>
    </head>
    <body>
        hello, world
    </body>
</html>
```

So, we get the same result as it was with `http-server`.

### -- Example `hello-3`

And now we can use an input:
- `request.args` - "args" is a dictionary of all key/value pairs that user might have provided;

> Our `index.html` file is not a simple HTML anymore , it is a "template", like a blueprint, in which we can
> have "placeholders".
> - `{{ ... }}` syntax is a part of `Jinja` - a web template engine for the Python programming language.

#### ---- hello-3/templates/`hello.html`

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- No matter how wide the device is, size the viewport to that device -->
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>hello</title>
    </head>
    <body>
        <!-- This .html file is not a simple HTML anymore -->
        <!-- It is a "template", like a blueprint, in which we can have "placeholders" -->
        <!-- {{ ... }} - a part of Jinja language -->
        hello, {{ placeholder }}
    </body>
</html>
```

#### ---- `app-3.py`

Now we need to switch `placeholder` to `name`:

```python
from flask import Flask, render_template, request

# Pass the file name to Flask, without specifying it
app = Flask(__name__)

# "/" - default folder
@app.route("/")
def index():
    name = request.args["name"]
    return render_template("index.html", placeholder=name)
```

And, as we didn't yet have an input form on our site, we need to give `key/value` pair manually:
- type `?name=David` after the domain address;
- if we didn't provide key/value, we get the `400 Bad Request` error;
  - error happens because we didn't provide a behaviour when there is no `name` existed. 

```
https://address.github.dev/?name=David
```

Now, if we will look at the **Page Source**, we will be able to notice the difference:
- our `placeholder` is indeed a `name` now

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- No matter how wide the device is, size the viewport to that device -->
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>hello</title>
    </head>
    <body>
        hello, David
    </body>
</html>
```

- `index.html` is a static file;
- Dynamically we served the file plus substitution or interpolation of the `placeholder` variable.

### -- Example `hello-4`

Let's fix our previous `400 Bad Request` error:

#### ---- `app-4.py`

```python
from flask import Flask, render_template, request

# Pass the file name to Flask, without specifying it
app = Flask(__name__)

# "/" - default folder
@app.route("/")
def index():
    # If `name` exists
    if "name" in request.args:
        name = request.args["name"]
    # If no name were provided
    else:
        name = "world"
    return render_template("index.html", placeholder=name)
```

Now our website is working with and without an argument:

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- No matter how wide the device is, size the viewport to that device -->
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>hello</title>
    </head>
    <body>
        hello, David
    </body>
</html>
```

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- No matter how wide the device is, size the viewport to that device -->
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>hello</title>
    </head>
    <body>
        hello, world
    </body>
</html>
```

### -- Example `hello-5`

We can make our code better.

Instead of treating `args[]` as a dictionary with square brackets (it will cause trouble if the key doesn't exist),
we can use a dictionary function `get("key", None)`:
- `None` means if there is no "key" return some kind of Python's equivalent of NULL;
- This function also can contain two keys like `get("key1", "key2")`, so the default value will be `key2`.

#### ---- `app-5.py`

```python
from flask import Flask, render_template, request

# Pass the file name to Flask, without specifying it
app = Flask(__name__)

# "/" - default folder
@app.route("/")
def index():
    # If there is no key "name", use a default key "world"
    name = request.args.get("name", "world")
    return render_template("index.html", name=name)
```

Also, let's use name `"name"` for a `placeholder`:

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- No matter how wide the device is, size the viewport to that device -->
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>hello</title>
    </head>
    <body>
        hello, {{ name }}
    </body>
</html>
```

## Forms

### -- Example `hello-6`

Let's use a form to get an input from the user.

#### ---- hello-6/templates/`index.html`

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- No matter how wide the device is, size the viewport to that device -->
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>hello</title>
    </head>
    <body>
        <!-- 'greet' isn't a folder, it's a path or a rout -->
        <form action="/greet" method="get">
            <input autocomplete="off" autofocus name="name" placeholder="Name" type="text">
            <button type="submit">Greet</button>
        </form>
    </body>
</html>
```

Notice that if we write any input in our form and submit it, we get an error `404 Not Found`.
- We didn't implement our route `greet` yet.

#### ---- 'app-6.py'

```python
from flask import Flask, render_template, request

# Pass the file name to Flask, without specifying it
app = Flask(__name__)

# "/" - default folder
@app.route("/")
def index():
    return render_template("index.html")

@app.route("/greet")
def greet():
    name = request.args.get("name", "world")
    return render_template("greet.html", name=name)
```

#### ---- hello-6/templates/'index.html'

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- No matter how wide the device is, size the viewport to that device -->
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>hello</title>
    </head>
    <body>
        <!-- 'greet' isn't a folder, it's a path or a rout -->
        <form action="/greet" method="get">
            <input autocomplete="off" autofocus name="name" placeholder="Name" type="text">
            <button type="submit">Greet</button>
        </form>
    </body>
</html>
```

Let's create `greet.html`

#### ---- `greet.html`

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- No matter how wide the device is, size the viewport to that device -->
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>hello</title>
    </head>
    <body>
        hello, {{ name }}
    </body>
</html>
```

Now we get user's input on `index.html` and use it on `greet.html`.

> ### But what is wrong?
> `index.html` and `greet.htmlz` have the same contents except for a few lines of code.
> 
> > **Generally, having duplication of anything is a bad design.**

### -- Example `hello-7`

Let's write a layout for our webpage at first:

#### ---- hello-7/templates/'layout.html'

```html
<!DOCTYPE html>

<html lang="en">
<head>
  <meta name="viewport" content="initial-scale=1, width=device-width">
  <title>hello</title>
</head>
<body>
  <!-- Jinja syntax -->
  <!-- Now it is a placeholder for a block of code -->
  {% block body %}{% endblock %}
</body>
</html>
```

Now we can use our template on other pages:

#### ---- hello-7/templates/'index.html'

```html
<!DOCTYPE html>
<!-- Get everything from layout.html and hand it to browser -->
{% extends "layout.html" %}

<!-- Jinja template -->
{% block body %}

    <form action="/greet" method="get">
        <input autocomplete="off" autofocus name="name" placeholder="Name" type="text">
        <button type="submit">Greet</button>
    </form>

<!-- Jinja template -->
{% endblock %}
```

#### ---- hello-7/templates/'greet.html'

```html
<!-- Get everything from layout.html and hand it to browser -->
{% extends "layout.html" %}

<!-- Jinja template -->
{% block body %}

    hello, {{ name }}

<!-- Jinja template -->
{% endblock %}
```

Finally, we have no duplication and an input form is working too.

---

## Request methods

You can imagine scenarios where it is not safe to utilize _method_ `get`, as **usernames and passwords would show up** in the URL.

We can utilize the _method_ `post` to help with this problem:

### -- Example hello-post

#### ---- hello-post/`index.html`

```html
<!DOCTYPE html>
{% extends "layout.html" %}

{% block body %}

    <!-- Change method `get` to `post` -->
    <form action="/greet" method="post">
        <input autocomplete="off" autofocus name="name" placeholder="Name" type="text">
        <button type="submit">Greet</button>
    </form>

<!-- Jinja template -->
{% endblock %}
```

> If we run Flask, write input to our form and click "submit", we get an error `405 Method Not Allowed`:
> - The reason is that the method the user is using is not supported.
> 
> The default is method `get`, you don't need to type this:
> ```python
> @app.route("/greet", methods=["GET"])
> ```
> But you need to change it for method `post`:
> ```python
> @app.route("/greet", methods=["POST"])
> ```
> There is a way to use several methods:
> ```python
> @app.route("/greet", methods=["GET", "POST"])
> ```

We can easily make minor changes to `app.py`:

```python
from flask import Flask, render_template, request

app = Flask(__name__)

@app.route("/")
def index():
    return render_template("index.html")

# Change 'get' to 'post'
@app.route("/greet", methods=["POST"])
def greet():
    name = request.args.get("name", "world")
    return render_template("greet.html", name=name)
```

The site is working now, but there is no name. Why is that?
- If `world` is a value of the `name` placeholder
- There must be the case, where there is no `name` key in `request.args`.
- To avoid this, we can use an `request.args` alternative - `request.form`.


```python
from flask import Flask, render_template, request

app = Flask(__name__)

@app.route("/")
def index():
    return render_template("index.html")

# Change 'get' to 'post'
@app.route("/greet", methods=["POST"])
def greet():
    # Change 'request.args' to 'request.form'
    name = request.form.get("name", "world")
    return render_template("greet.html", name=name)
```

> - If you are using method `GET`, you can use `request.args`
> - If you are using method `POST`, you need to use `request.form`

Now, we get the greeting with a user input and there is no duplication of input in URL.

### Multiple methods

If we want to use multiple methods, we can do this:

#### ---- hello-methods/`app.py`

```python
from flask import Flask, render_template, request

# Pass the file name to Flask, without specifying it
app = Flask(__name__)

# "/" - default folder
@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        name = request.form.get("name", "world")
        return render_template("greet.html", name=name)
    return render_template("index.html")
```

#### ---- hello-methods/`index.html`

```html
<!DOCTYPE html>
{% extends "layout.html" %}

{% block body %}

    <!-- We don't need to specify 'greet' anymore -->
    <!-- <form method="post"> will work too-->
    <form action="/" method="post">
        <input autocomplete="off" autofocus name="name" placeholder="Name" type="text">
        <button type="submit">Greet</button>
    </form>

{% endblock %}
```

> Even though, everything is working well now, we have a "bug":
> - We have a default word "world" for an empty form, but even if the form is empty and doesn't contain anything, 
> the browser still going to submit a name parameter with a blank value, so-called `empty-string`.
> 
> So, with an empty form we will see on our page only hello without a name:
> ```
> hello, 
> ```

#### ---- hello-methods/`greet.html`

```html
<!-- Get everything from layout.html and hand it to browser -->
{% extends "layout.html" %}

<!-- Jinja template -->
{% block body %}

    hello, {% if name %}{{ name }}{% else %}world{% endif %}

<!-- Jinja template -->
{% endblock %}
```

---

## Frosh IMs

**Frosh IMs** or "froshims" is a web application that allows students to register for intramural sports.

### -- Frosh IMs #1

#### ---- froshims-1/templates/`index.html`
- <input ... `required`> means that we need this input be filled to submit the form;
  - `required` **not the secure way** to do smth like this! Because it may be easily exclude through browser's
  developer kit.
- `<option disabled selected value="">Sport</option>` - default empty value to avoid random select;

```html
{% extends "layout.html" %}

{% block body %}

    <h1>Register</h1>
    <form action="/register" method="post">
        <input autocomplete="off" autofocus name="name" placeholder="Name" required type="text">
        <select name="sport">
            <option disabled selected value="">Sport</option>
            <option>Basketball</option>
            <option>Soccer</option>
            <option>Ultimate Frisbee</option>
        </select>
        <button type="submit">Register</button>
    </form>

{% endblock %}
```

It is better to remove `required` from the input and make some changes in `app.py`:

#### ---- froshims-1/`app.py`
- it's conventional to name the function after the route.

```python
from flask import Flask, render_template, request

app = Flask(__name__)

@app.route("/")
def index():
    return render_template("index.html")

@app.route("/register", methods=["POST"])
def register():
    if not request.form.get("name") or not request.form.get("sport"):
        return render_template("failure.html")
    return render_template("success.html")
```

Let's create `success` and `failure` pages:

#### ---- froshims-1/templates/`success.html`

```html
{% extends "layout.html" %}

{% block body %}

    Register success!

{% endblock %}
```

#### ---- froshims-1/templates/`failure.html`

```html
{% extends "layout.html" %}

{% block body %}

    Register error.

{% endblock %}
```

It's working now, we get success only if there is a name input and selected sport. But we can do better.

### -- Frosh IMs #2

> Our web application is not secure:
> - User can change freely all the options we provided within sports selector;
> - Our validation checker is working with **any** input now.
> 
> We can extract selector from the page for better design.

- We can create a global variable `SPORTS`;
- Make it a list of sports;
- Passed into `index.html`;
- Use Jinja syntax in `index.html` instead of previous selector.

> #### Naming
> UPPERCASE and lowercase is not necessary to use, but for better readability we can separate actual variables from
> placeholders with a name in uppercase for them:
> - _placeholder_ `sports` `=` _actual variable_ `SPORTS`

#### ---- froshims-2/templates/`index.html`

```html
{% extends "layout.html" %}

{% block body %}

<h1>Register</h1>
<form action="/register" method="post">
  <input autocomplete="off" autofocus name="name" placeholder="Name" type="text">
  <select name="sport">
    <option disabled selected value="">Sport</option>
    <!-- Jinja loop -->
    {% for sport in sports %}
        <option value="{{ sport }}">{{ sport }}</option>
    {% endfor %}
  </select>
  <button type="submit">Register</button>
</form>

{% endblock %}
```

#### ---- froshims-2/`app.py`
Now we need to validate those sports:
- `if not request.form.get("name") or request.form.get("sport") not in SPORTS:`

```python
from flask import Flask, render_template, request

app = Flask(__name__)

SPORTS = ["Basketball", "Soccer", "Ultimate Frisbee"]

@app.route("/")
def index():
  return render_template("index.html", sports=SPORTS)

@app.route("/register", methods=["POST"])
def register():
  if not request.form.get("name") or request.form.get("sport") not in SPORTS:
    return render_template("failure.html")
  return render_template("success.html")
```

Now we have a correct validation of the selector.

### -- Frosh IMs #3

Let's try a different approach. Let's change `GUI` (Graphical User Interface).

We can use radio buttons that are mutually exclusive.

#### ---- froshims-3/templates/`index.html`

```html
{% extends "layout.html" %}

{% block body %}

    <h1>Register</h1>
    <form action="/register" method="post">
        <input autocomplete="off" autofocus name="name" placeholder="Name" type="text">
        {% for sport in sports %}
            <input name="sport" type="radio" value="{{ sport }}"> {{ sport }}
        {% endfor %}
        <button type="submit">Register</button>
    </form>

{% endblock %}
```

Now we have radio buttons on our page.

### -- Frosh IMs #4

What if we need to register on several sport types? Let's try to use checkboxes.

#### ---- froshims-4/templates/`index.html`

```html
{% extends "layout.html" %}

{% block body %}

    <h1>Register</h1>
    <form action="/register" method="post">
        <input autocomplete="off" autofocus name="name" placeholder="Name" type="text">
        {% for sport in sports %}
            <input name="sport" type="checkbox" value="{{ sport }}"> {{ sport }}
        {% endfor %}
        <button type="submit">Register</button>
    </form>

{% endblock %}
```

Indeed, there are checkboxes on our page, but the problem is that we're only expecting one value.

#### ---- froshims-4/`app.py`

To get all the sports we need to change validation in `app.py`:
- `getlist()` gets all instead of one element.

```python
from flask import Flask, render_template, request

app = Flask(__name__)

SPORTS = ["Basketball", "Soccer", "Ultimate Frisbee"]

@app.route("/")
def index():
  return render_template("index.html", sports=SPORTS)

@app.route("/register", methods=["GET", "POST"])
def register():
  if not request.form.get("name"):
    return render_template("failure.html")
  for sport in request.form.getlist("sport"):
    if sport not in SPORTS:
      return render_template("failure.html")
  return render_template("success.html")
```

### -- Frosh IMs #5

Now we can add another feature and make some changes:
- Create custom error messages;
- Show image on the error page;
- Let's remember registrant and their choice;
  - Register registrants with a dictionary `REGISTRANTS` and list `SPORTS`;
    - `name` as a **key**, `sport` as a **value**;
  - Put person's name into dictionary and associate a value with a key `REGISTRANTS[name] = sport`;
- Add new route `/registrants` (successful `/register` will redirect us to `/registrants`);
  - For that action we need to import Flask function `redirect`.


#### ---- froshims-5/`app.py`

```python
# Implements a registration form, storing registrants in a dictionary, with error messages

from flask import Flask, redirect, render_template, request

app = Flask(__name__)

REGISTRANTS = {}

SPORTS = [
    "Basketball",
    "Soccer",
    "Ultimate Frisbee"
]


@app.route("/")
def index():
    return render_template("index.html", sports=SPORTS)


@app.route("/register", methods=["POST"])
def register():

    # Validate name
    name = request.form.get("name")
    if not name:
        return render_template("error.html", message="Missing name")

    # Validate sport
    sport = request.form.get("sport")
    if not sport:
        return render_template("error.html", message="Missing sport")
    if sport not in SPORTS:
        return render_template("error.html", message="Invalid sport")

    # Remember registrant
    REGISTRANTS[name] = sport

    # Confirm registration
    return redirect("/registrants")


@app.route("/registrants")
def registrants():
    return render_template("registrants.html", registrants=REGISTRANTS)
```

### -- Frosh IMs #6 with SQL

Let's use SQL this time, because using global dictionaries is not a good design, we will lose those data instantly. So,
we can try to save our data into `.db` file.

1. Import `SQL` from `CS50` lib
2. Open file `froshims.db`
3. User can now deregister from the sport
4. We are inserting nodes into table registrants from `froshims.db`
5. Within `/registrants`:
   - we select all registrants and getting back a list of dictionaries;
   - then we're passing that list into Jinja template.

> We just implemented the `MVC` paradigm, "Model View Controller":
> - `view` is everything that the user sees (templates, HTML, CSS, JavaScript);
> - `controller` is everything from app.py, the logic of our app;
> - `model` is all scored data (a database or even a global dictionary)

#### ---- froshims-6/`app.py`

```python
# Implements a registration form, storing registrants in a SQLite database, with support for deregistration

from cs50 import SQL
from flask import Flask, redirect, render_template, request

app = Flask(__name__)

db = SQL("sqlite:///froshims.db")

SPORTS = [
    "Basketball",
    "Soccer",
    "Ultimate Frisbee"
]


@app.route("/")
def index():
    return render_template("index.html", sports=SPORTS)


@app.route("/deregister", methods=["POST"])
def deregister():

    # Forget registrant
    id = request.form.get("id")
    if id:
        db.execute("DELETE FROM registrants WHERE id = ?", id)
    return redirect("/registrants")


@app.route("/register", methods=["POST"])
def register():

    # Validate submission
    name = request.form.get("name")
    sport = request.form.get("sport")
    if not name or sport not in SPORTS:
        return render_template("failure.html")

    # Remember registrant
    db.execute("INSERT INTO registrants (name, sport) VALUES(?, ?)", name, sport)

    # Confirm registration
    return redirect("/registrants")


@app.route("/registrants")
def registrants():
    registrants = db.execute("SELECT * FROM registrants")
    return render_template("registrants.html", registrants=registrants)
```

#### ---- froshims-6/templates/`registrants.html`

```html
{% extends "layout.html" %}

{% block body %}
    <h1>Registrants</h1>
    <table>
        <thead>
            <tr>
                <th>Name</th>
                <th>Sport</th>
                <th></th>
            </tr>
        </thead>
        <tbody>
            {% for registrant in registrants %}
                <tr>
                    <td>{{ registrant.name }}</td>
                    <td>{{ registrant.sport }}</td>
                    <td>
                        <form action="/deregister" method="post">
                            <input name="id" type="hidden" value="{{ registrant.id }}">
                            <button type="submit">Deregister</button>
                        </form>
                    </td>
                </tr>
            {% endfor %}
        </tbody>
    </table>
{% endblock %}
```

---

## Cookies and sessions

While the above code is useful from an administrative standpoint, where a back-office administrator could add
and remove individuals from the database, one can imagine how this code is not safe to implement on a public server.

- For one, bad actors could make decisions on behalf of other users by hitting the deregister button – 
effectively deleting their recorded answer from the server.

> Web services like Google use login credentials to ensure users only have access to the right data.

We can actually implement this itself using cookies. Cookies are small files that are stored on your computer,
such that your computer can communicate with the server and effectively say, “I’m an authorized user that has 
already logged in.” This authorization through this cookie is called a session.

When you first logged-in on the website, the web server creates a `cookie`, some kind of unique identifier that
confirms you were on this website:
- `session=value` is a `key=value` pair.

```
HTTP/2 200
Content-Type: text/html
Set-Cookie: session=value
...
```

Next time you visit the same server, the browser reminds that server what cookie was set:

```
GET / HTTP/2
Host: accounts.google.com
Cookie: session=value
...
```

In the simplest form, we can implement this by creating a folder called login and then adding the following files.

First, create a file called `requirements.txt` that reads as follows:

```
Flask
Flask-Session
```

#### --- `app.py`

```python
# Add session
from flask import Flask, redirect, render_template, request, session
# Import session library
from flask_session import Session

app=Flask(__name__)

# Session config
app.config["SESSION_PERMANENT"] = False # cookie deletes when browser is closed
app.config["SESSION_TYPE"] = "filesystem" # privacy: insures that content of your shopping cart are stored in the server's files, not in a cookie itself
Session(app) # activates session

@app.route("/")
def index():
    # Pass name to the homepage
    return render_template("index.html", name=session.get("name"))

# Create route login
@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        # Use session variable, an empty dictionary `session = {}`
        # It is like a global variable, but session guarantees unique items inside
        session["name"] = request.form.get("name")
        # Redirect user to the homepage
        return redirect("/")
    return render_template("login.html")

# there are no login.html page, only route
@app.route("/logout")
def logout():
    # Clears all contents of the session
    session.clear()
    # Redirects to the homepage
    return redirect("/")
```

#### ---- `index.html`

```html
{% extends "layout.html" %}

{% block body %}

    <!-- If the user is logged in with a name -->
    {% if name %}

        You are logged in as {{ name }}. <a href="/logout">Log out</a>.

    {% else %}

        You are not logged in. <a href="/login">Log in</a>.
        
    {% endif %}

{% endblock %}
```

#### ---- `layout.html`

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>login</title>
    </head>
    <body>
        {% block body %}{% endblock %}
    </body>
</html>
```

#### ---- "login.html"

```html
{% extends "layout.html" %}

{% block body %}

    <form action="/login" method="post">
        <input autocomplete="off" autofocus name="name" placeholder="Name" type="text">
        <button type="submit">Log In</button>
    </form>

{% endblock %}
```

> Notice the modified _imports_ at the top of the file, including `session`, which will allow for you to support
> sessions. Most important, notice how `session["name"]` is used in the `login` and `logout` routes.
> - The `login` route will assign the login name provided and assign it to `session["name"]`.
> - In the `logout` route, the logging out is implemented by clearing the value of `session`.
> > More about `sessions` in [Flask Documentation](https://flask.palletsprojects.com/en/2.2.x/api/?highlight=session#flask.session).

---

## Shopping cart

Let's create a simple shopping cart.

#### ---- `app.py`

```python
from cs50 import SQL
from flask import Flask, redirect, render_template, request, session
from flask_session import Session

# Configure app
app = Flask(__name__)

# Connect to database
db = SQL("sqlite:///store.db")

# Configure session
app.config["SESSION_PERMANENT"] = False
app.config["SESSION_TYPE"] = "filesystem"
Session(app)


@app.route("/")
def index():
    # Returns "books", the list of dictionaries, from database
    books = db.execute("SELECT * FROM books")
    return render_template("books.html", books=books)


@app.route("/cart", methods=["GET", "POST"])
def cart():

    # Ensure cart exists, even if its empty
    if "cart" not in session:
        session["cart"] = []

    # If smth was submitted into cart, do POST
    if request.method == "POST":
        # Grabs the book's id
        book_id = request.form.get("id")
        # Checks valid id
        if book_id:
            # Go into list "cart" and add the book with that id
            session["cart"].append(book_id)
        return redirect("/cart")

    # GET
    # Grab books that were bought, search the list "books" for their id's
    # Within CS50 lib you can use `(?)` as a placeholder, it will generate commas between id's for you
    books = db.execute("SELECT * FROM books WHERE id IN (?)", session["cart"])
    # Opens cart.html
    return render_template("cart.html", books=books)
```

#### ---- `books.html`

```html
{% extends "layout.html" %}

{% block body %}

    <h1>Books</h1>
    {% for book in books %}
        <h2>{{ book["title"] }}</h2>
        <form action="/cart" method="post">
            <!-- Creates unique id for each book -->
            <input name="id" type="hidden" value="{{ book['id'] }}">
            <button type="submit">Add to Cart</button>
        </form>
    {% endfor %}

{% endblock %}
```

#### ---- `cart.html`

```html
{% extends "layout.html" %}

{% block body %}

<h1>Cart</h1>
<ol>
    {% for book in books %}
    <li>{{ book["title"] }}</li>
    {% endfor %}
</ol>

{% endblock %}
```

#### ---- `layout.html`

```html
<!DOCTYPE html>

<html lang="en">
<head>
    <meta name="viewport" content="initial-scale=1, width=device-width">
    <title>store</title>
</head>
<body>
    {% block body %}{% endblock %}
</body>
</html>
```
> Notice that `cart` is implemented using a _list_. Items can be added to this list using the `Add to Cart` buttons
> in `books.html`. When clicking such a button, the `post` method is invoked, where the `id` of the item is appended
> to the `cart`. When viewing the cart, invoking the `get` method, **SQL** is executed to display a list of
> the books in the cart.

---

## Shows

Let's create a search application.

---

### -- Shows #0

Our original version searches for movies/serials, but it is case-sensitive, that is not good for search apps.

#### ---- shows-0/`app.py`

```python
# Searches for shows

from cs50 import SQL
from flask import Flask, render_template, request

app = Flask(__name__)

db = SQL("sqlite:///shows.db")


@app.route("/")
def index():
    return render_template("index.html")


@app.route("/search")
def search():
    shows = db.execute("SELECT * FROM shows WHERE title = ?", request.args.get("q"))
    return render_template("search.html", shows=shows)
```

#### ---- shows-0/`index.html`

```html
{% extends "layout.html" %}

{% block body %}

    <form action="/search" method="get">
        <input autocomplete="off" autofocus name="q" placeholder="Query" type="search">
        <button type="submit">Search</button>
    </form>

{% endblock %}
```

#### ---- shows-0/`search.html`

```html
{% extends "layout.html" %}

{% block body %}

    <ul>
        {% for show in shows %}
            <li>{{ show["title"] }} - {{ show["year"] }}</li>
        {% endfor %}
    </ul>

{% endblock %}
```

#### ---- shows-0/`layout.html`

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>shows</title>
    </head>
    <body>
        {% block body %}{% endblock %}
    </body>
</html>
```

---

### -- Shows #1

We can make our search less strict and look for the word case-insensitively in entire string.

#### ---- shows-1/`app.py`

Instead of using `=` within `/search` route definition, we can use another SQL command `LIKE`.

But we need to use it carefully and prevent user from the dangerous input:
- You should not use an `f-string` for this thing;
- We can slightly change the argument `request.args.get("q")`;
- `"%" + q + "%"` gets plugged in into the placeholder and therefore escaped.

```python
# Searches for shows using LIKE

from cs50 import SQL
from flask import Flask, render_template, request

app = Flask(__name__)

db = SQL("sqlite:///shows.db")


@app.route("/")
def index():
    return render_template("index.html")


@app.route("/search")
def search():
    q = request.args.get("q")
    shows = db.execute("SELECT * FROM shows WHERE title LIKE ?", "%" + q + "%")
    return render_template("search.html", shows=shows)
```

Now our application searches for the entered word in entire title.

> Thia approach of generating new HTML every time a user submits input or visits a new URL is increasingly
> dated whereby every URL is unique, as opposed to apps being much more interactive.

---

### -- Shows #2

`AJAX` (**Asynchronous JavaScript And XML**) -  a set of web development techniques that uses various web technologies
on the client-side to create asynchronous web applications. _For example, even though the page is reloading, the browser
doesn't flash._

In `Shows #2` we have an _autocomplete_ for input:
- It is impossible to have an autocomplete when you are constantly reloading the whole page;
- In out example you can type the first letter, get autocomplete, then the other, autocomplete changes, but there are
now reloading at all and the URL stays the same.

How it works? You can go to `Network` tab within developer's tool and notice:
- When you type any `input`, an HTTP request `search?q=input` sent from your browser to the URL;
- Response of that request is `200` and what it have inside is a list of shows `<li>show-title</li>`.

#### ---- shows-2/templates/`index.html`

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>shows</title>
    </head>
    <body>
        <!-- Input of type "search" -->
        <input autocomplete="off" autofocus placeholder="Query" type="search">

        <!-- An empty list -->
        <ul></ul>

        <!-- JavaScript code -->
        <script>
            // Set the variable "input" to the DOM element <input>
            let input = document.querySelector('input');
            // Listen to that "input"
            // Run an asynchronous function, that going to get back eventually
            // (if the server is slow, it might take a moment)
            input.addEventListener('input', async function() {
                // Fetch url + input
                let response = await fetch('/search?q=' + input.value);
                // Wait for response, text() is the list of shows
                let shows = await response.text();
                // Select <ul> element, go into its inner HTML, set it to the list of shows
                document.querySelector('ul').innerHTML = shows;
            });

        </script>

    </body>
</html>
```

#### ---- shows-2/`app.py`

```python
# Searches for shows using Ajax

from cs50 import SQL
from flask import Flask, render_template, request

app = Flask(__name__)

db = SQL("sqlite:///shows.db")


@app.route("/")
def index():
    return render_template("index.html")


@app.route("/search")
def search():
    q = request.args.get("q")
    if q:
        shows = db.execute("SELECT * FROM shows WHERE title LIKE ? LIMIT 50", "%" + q + "%")
    # Shows empty list without input
    else:
        shows = []
    return render_template("search.html", shows=shows)
```

#### ---- shows-2/templates/`search.html`

```html
{% for show in shows %}
    <li>{{ show["title"] }}</li>
{% endfor %}
```

When we input some text on our page, e.g. "the office", we get data like this:
- As you can see, this data is not very useful and comfortable.

```
<li>Nice Day at the Office</li>

<li>The Office</li>

<li>The Office</li>

<li>A Nice Day at the Office</li>

<li>The Office</li>

...
```

> ❌ Nowadays, it's not common to use **HTML** (like a list of `<li>` in our case) nor **XML** to send back your data.
> 
> ✅ It's more common to get `JSON` (**JavaScript Object Notation**). It looks very similar to a dictionary.
> - You have to use double quotes `"` around your strings in **JSON**.
> ```json
> [
>   {"id": 1, "title": "The Hitchhiker's Guide to the Galaxy"},
>   {"id": 2, "title": "The Restaurant at the End of the Universe"},
>   {"id": 3, "title": "Life, the Universe and Everything"},
>   {"id": 4, "title": "So Long, and Thanks for All the Fish"},
>   {"id": 5, "title": "Mostly Harmless"},
>   ...
> ]
> ```

### -- Shows #3

> An **application program interface** or `API` is a series of specifications that allow you to interface with
> another service. For example, we could utilize **IMDB**’s **API** to interface with their database.
> We might even integrate **API**s for handling specific types of data downloadable from a server.

Let's use `JSON` in our search app. The result will look the same as it was in `Shows #2`, but look here:

#### ---- shows-3/`app.py`

````python
# Searches for shows using Ajax with JSON

from cs50 import SQL
# Import jsonify function (turn smth to JSON)
from flask import Flask, jsonify, render_template, request

app = Flask(__name__)

db = SQL("sqlite:///shows.db")


@app.route("/")
def index():
    return render_template("index.html")

# The same code as it was in "shows-2"
@app.route("/search")
def search():
    q = request.args.get("q")
    if q:
        shows = db.execute("SELECT * FROM shows WHERE title LIKE ? LIMIT 50", "%" + q + "%")
    else:
        shows = []
    # BUT
    # Instead of passing any template, we turn that text to JSON
    return jsonify(shows)
````

When we input some text, e.g. "the office", we get much more **standardized data**:

```json
[
  {"episodes":6,"id":108878,"title":"Nice Day at the Office","year":1994},
  {"episodes":6,"id":112108,"title":"The Office","year":1995},
  {"episodes":14,"id":290978,"title":"The Office","year":2001},
  {"episodes":7,"id":377234,"title":"A Nice Day at the Office","year":1972},
  {"episodes":188,"id":386676,"title":"The Office","year":2005},
  ...
]
```