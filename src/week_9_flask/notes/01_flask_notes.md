# Week 9: Flask

Instructor: **[David J. Malan](https://github.com/dmalan)**

---

## Static to Dynamic

Up until this point, all HTML you saw was pre-written and `static`.

In the past, when you visited a page, the browser downloaded an **HTML** page, and you were able to view it. 
These are considered static pages, in that what programmed in the **HTML** is exactly what the user sees and 
downloads to their internet browser.

`Dynamic` pages refer to the ability of **Python** and similar languages to create **HTML** files on-the-fly. 
Accordingly, you can have _web pages that are generated by options selected by your user_.

We have used `http-server` in the past to serve our web pages on the problem set. Today, we are going to utilize
a new server that can parse out a web address and perform actions based on the URL provided.

> Last week, we focused on **websites**, this week we'll focus on **web applications**.

We are already familiar with addresses like these:

```
https://www.example.com/
https://www.example.com/file.html
https://www.example.com/folder/
https://www.example.com/folder/file.html
```

From now, we will think of everything after the domain name as a path or `route`:

```
https://www.example.com/route
```

But what makes it an application?
- With `key/value` websites can take an input.

```
https://www.example.com/route?key=value
https://www.example.com/route?key=value&key=value
https://www.example.com/route?key=value&key=value&key=value
```

## Flask

Flask - a third-party library or a microframework, makes easier to implement a web application using Python.

Previously, we use `http-server`, but to use Flask and start a web-server to run, we need to use another command:

```commandline
flask run
```

Flask has pieces of functionality, for example:
1. `Flask`
2. `render_template`
3. `request`

### -- Example `hello-1`

- `app.py` - our python program;
- `requirements.txt` - list of used third-party libraries;
- `static/` - a folder with images, .css, .js - files that ment to be static;
- `templates/` - a folder, where we'll keep .html.

At first, let's write a web application that simply greets everyone.

#### ---- `app-1.py`

```python
from flask import Flask, render_template, request

# Pass the file name to Flask, without specifying it
app = Flask(__name__)

# "/" - default folder
@app.route("/")
# route() defines the route of an application, so that when user visit "/" on this app
# it will call index() and write "hello, world"
def index():
    return "hello, world"
```

When we view the **Page Source** through browser we get just one line from .py:
```
hello, world
```

### -- Example `hello-2`

#### ---- `app-2.py`

```python
from flask import Flask, render_template, request

# Pass the file name to Flask, without specifying it
app = Flask(__name__)

# "/" - default folder
@app.route("/")
# route() defines the route of an application, so that when user visit "/" on this app
# it will call render_template()
def index():
    # render_template() gets the file, opens it and sends to user's browser
    return render_template("index.html")
```

This time our **Page Source** gets entire `index.html`:

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- No matter how wide the device is, size the viewport to that device -->
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>hello</title>
    </head>
    <body>
        hello, world
    </body>
</html>
```

So, we get the same result as it was with `http-server`.

### -- Example `hello-3`

And now we can use an input:
- `request.args` - "args" is a dictionary of all key/value pairs that user might have provided;

> Our `index.html` file is not a simple HTML anymore , it is a "template", like a blueprint, in which we can
> have "placeholders".
> - `{{ ... }}` syntax is a part of `Jinja` - a web template engine for the Python programming language.

#### ---- hello-3/templates/`hello.html`

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- No matter how wide the device is, size the viewport to that device -->
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>hello</title>
    </head>
    <body>
        <!-- This .html file is not a simple HTML anymore -->
        <!-- It is a "template", like a blueprint, in which we can have "placeholders" -->
        <!-- {{ ... }} - a part of Jinja language -->
        hello, {{ placeholder }}
    </body>
</html>
```

#### ---- `app-3.py`

Now we need to switch `placeholder` to `name`:

```python
from flask import Flask, render_template, request

# Pass the file name to Flask, without specifying it
app = Flask(__name__)

# "/" - default folder
@app.route("/")
def index():
    name = request.args["name"]
    return render_template("index.html", placeholder=name)
```

And, as we didn't yet have an input form on our site, we need to give `key/value` pair manually:
- type `?name=David` after the domain address;
- if we didn't provide key/value, we get the `400 Bad Request` error;
  - error happens because we didn't provide a behaviour when there is no `name` existed. 

```
https://address.github.dev/?name=David
```

Now, if we will look at the **Page Source**, we will be able to notice the difference:
- our `placeholder` is indeed a `name` now

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- No matter how wide the device is, size the viewport to that device -->
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>hello</title>
    </head>
    <body>
        hello, David
    </body>
</html>
```

- `index.html` is a static file;
- Dynamically we served the file plus substitution or interpolation of the `placeholder` variable.

### -- Example `hello-4`

Let's fix our previous `400 Bad Request` error:

#### ---- `app-4.py`

```python
from flask import Flask, render_template, request

# Pass the file name to Flask, without specifying it
app = Flask(__name__)

# "/" - default folder
@app.route("/")
def index():
    # If `name` exists
    if "name" in request.args:
        name = request.args["name"]
    # If no name were provided
    else:
        name = "world"
    return render_template("index.html", placeholder=name)
```

Now our website is working with and without an argument:

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- No matter how wide the device is, size the viewport to that device -->
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>hello</title>
    </head>
    <body>
        hello, David
    </body>
</html>
```

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- No matter how wide the device is, size the viewport to that device -->
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>hello</title>
    </head>
    <body>
        hello, world
    </body>
</html>
```

### -- Example `hello-5`

We can make our code better.

Instead of treating `args[]` as a dictionary with square brackets (it will cause trouble if the key doesn't exist),
we can use a dictionary function `get("key", None)`:
- `None` means if there is no "key" return some kind of Python's equivalent of NULL;
- This function also can contain two keys like `get("key1", "key2")`, so the default value will be `key2`.

#### ---- `app-5.py`

```python
from flask import Flask, render_template, request

# Pass the file name to Flask, without specifying it
app = Flask(__name__)

# "/" - default folder
@app.route("/")
def index():
    # If there is no key "name", use a default key "world"
    name = request.args.get("name", "world")
    return render_template("index.html", name=name)
```

Also, let's use name `"name"` for a `placeholder`:

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- No matter how wide the device is, size the viewport to that device -->
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>hello</title>
    </head>
    <body>
        hello, {{ name }}
    </body>
</html>
```

## Forms

### -- Example `hello-6`

Let's use a form to get an input from the user.

#### ---- hello-6/templates/`index.html`

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- No matter how wide the device is, size the viewport to that device -->
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>hello</title>
    </head>
    <body>
        <!-- 'greet' isn't a folder, it's a path or a rout -->
        <form action="/greet" method="get">
            <input autocomplete="off" autofocus name="name" placeholder="Name" type="text">
            <button type="submit">Greet</button>
        </form>
    </body>
</html>
```

Notice that if we write any input in our form and submit it, we get an error `404 Not Found`.
- We didn't implement our route `greet` yet.

#### ---- 'app-6.py'

```python
from flask import Flask, render_template, request

# Pass the file name to Flask, without specifying it
app = Flask(__name__)

# "/" - default folder
@app.route("/")
def index():
    return render_template("index.html")

@app.route("/greet")
def greet():
    name = request.args.get("name", "world")
    return render_template("greet.html", name=name)
```

#### ---- hello-6/templates/'index.html'

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- No matter how wide the device is, size the viewport to that device -->
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>hello</title>
    </head>
    <body>
        <!-- 'greet' isn't a folder, it's a path or a rout -->
        <form action="/greet" method="get">
            <input autocomplete="off" autofocus name="name" placeholder="Name" type="text">
            <button type="submit">Greet</button>
        </form>
    </body>
</html>
```

Let's create `greet.html`

#### ---- `greet.html`

```html
<!DOCTYPE html>

<html lang="en">
    <head>
        <!-- No matter how wide the device is, size the viewport to that device -->
        <meta name="viewport" content="initial-scale=1, width=device-width">
        <title>hello</title>
    </head>
    <body>
        hello, {{ name }}
    </body>
</html>
```

Now we get user's input on `index.html` and use it on `greet.html`.

> ### But what is wrong?
> `index.html` and `greet.htmlz` have the same contents except for a few lines of code.
> 
> > **Generally, having duplication of anything is a bad design.**

